2023.05.12

--------------------------
- 참조형 변수
- 오버로드/오버라이딩
- 상속, object 클래스
- 생성자 메소드

------------------------------

** object 클래스는 모든 클래스의 조상 클래스

부모 클래스는 자식 클래스가 정의하지 않아도 사용됨
- 자바에서 모든 클래스가 쓸 수 있는 메소드는 옵젝트 클래스에서 정의해놓은 것
   (가장 공통적인 것, 공통적인 속성을 가진 것들을 오브젝트 클래스가 제공)
	-> 이퀄스 메소드 (주소 비교가 아닌 내용 비교)
	-> 투스트링 메소트 (객체정보를 반환하는메소드)
	-> 웨이트, 노티파이 (스레드 처리?)
- 자식 클래스에서 자기거처럼 쓸 수 있음

-배열은 클래스는 아닌데 클래스가 가진 성질을 가지고 있음
- 이것이 자바다,,,, 책 어려움............................................ 나중에 봐야징

<생성자 메소드>
-(멤버변수) 객체 초기화
-멤버변수의 값을 초기화하기 위한 메소드
-C++ 는 생성자, 소멸자 있음 
-자바는 소멸자 없이 object 에서 제공하는 파이널라이즈가 자동 호출되어서 사용 끝난 객체 주소는
  자동으로 운영체제에 반납( garbage collecter- > 메모리 반납)


// 오버로딩
한 클래스 내에서 이름이 똑같은 메소드가 복수로 존재하는 것
목적 : 다양한 데이터 취급
반환타입 필요없고 매개변수의 갯수가 다르던지 매개변수의 타입이 다르면 메소드 이름이 똑같아도 상관없이 다른 메소드로 취급함
단일 클래스에서 발생


// 오버라이딩 @Override
public String toString() {
	
상속관계의 두개이상의 클래스에서 발생
부모클래스에서 정의한 메소드를 자식 클래스에서 재정의하는 것

Person() {} // 매개변수x (기본 생성자) // 생성자 메소드는 new 다음 메소드 -> 
	
Person(String name, int age){ // 메소드 오버로딩? 한클래스 내에서 이름이 똑같은 메소드
								
		this.name = name;
		this.age = age;

* 클래스 만들면 생성자 메소드 만드는거 습관적으로 해야함

모든 클래스는 생성자 메소드가 반드시 하나 이상 있어야함
-> 자바 컴파일러가 Person() {}  이 형식의 메소드를 자동 삽입
-> 사용자가 생성자 메소드를 하나 이상 만들면 컴파일러가 자동으로 만들지 않음

-----------------------------------------
배열

index 이용해서 데이터를 구별하는 방법 ( 배열 array)
일반형을 저장하진 못하고 객체로 저장해야됨 (wrapper class로 박싱)
		-> 일반형 데이터 -> 객체로 하기 위해 (8개로 동일)를 박스에 집어넣음 (boxing)
	오토언박싱, 오토박싱은 사용자가 알지 못함 (?) 
단점1. 같은 타입의 데이터만
단점2. 연속적인 메모리
단점3. 한번 설정해놓은 크기를 늘리거나 줄일 수 없음 (immutable, 변경불가)

int 타입은 일반 기본형 -> 객체 아님
객체는 주소값을 저장하는 변수타입
일반 변수랑 객체

배열 선언 - 정의 new 연산자 사용해서 배열공간을 heap메모리에 만들어 줘야함 - 배열 초기화 (초기화 하지 않으면 자동 초기값이 들어감 숫자인 경우 0, 0.0f, 한칸 공백, null 값)
배열명은 참조형의 특징 데이터를 직접 할당할 수 없음
	주소를 가지고 있기 때문에
일반 변수가 아니고 참조형 변수이기 때문에 생성할 때 빼고는 =연산자 옆에 쓸수 없음

|    |    |     |     |
[  0][  1][  2][  3][  4] - 인덱스

num = 150; 안됨 (배열명은 일반 변수 아니고 참조형 변수라)
num[0] 배열요소가 변수(변수는 =연산자 왼편에) 
	따라서, num[0] = 150; 으로 쓸 수 있다.
배열요소를 이요해서 기술해줘야함.
배열명은 절대로 생성 시점 빼고는 =연산자 왼편에서 값을 할당할 수 없음.

배열은 length라는 고정된 길이를 가지고 있음
	배열이 가지고 있는 공간의 갯수 (갯수는 1부터 카운팅)를 반환

--------------------------------------------

타입명 [  ] 변수명 ;
배열선언자

타입명 [  ] [   ] -> 2차원


배열선언자 - > 참조형 타입변수
참조형은 만들고 나서 특별한 처리 없으면 널 값

int [   ] number ;
호출스택에 생성 ?????????????
	배열의 시작위치를 알려주는 공간
선언에서는 배열 아직 안만들어짐

생성은 배열명 = new 타입[ 크기(정수로)]
	ex) new int [5]  - new 연산자에 의해 만들어진 저장장소 5개 만들어지고 이거의 시작 주소

대부분 선언과 생성이 결합되게 씀
타입 [  ] 배열명 = new 타입 [크기 ];
 * (선언 - 생성 )- 초기화
배열 초기화는 배열요소 = 값 (int [  ] number = new int [ 5];)
number[0] = 10;
...
값이 불규칙적일 경우 하나씩 집어넣음 (초기화)
	-> 하나로 묶어서 기술함
		타입 [  ] 배열명 = {초기값} ; (초기값을 설정해주면서 선언, 생성해줌 - 가장 많이 쓰는 방법)
ex ) int [  ] number = { 10, 5, 1, ...55} ; 
    {			}안의 값이 불규칙 할 경우 사용하고,
    규칙적인 경우에는 반복문 사용

   int [  ] number new int[ ]{ 10, 5, 1, ...55} ; 이렇게는 잘 안씀
		**이 괄호안에 갯수 넣으면 오류! 컴파일러가 알아서 세어서 넣어줌
 ----------------------------
예제 1. 정수 5개를 저장하는 배열을 생성하고, 10,20,30,40,50을 저장한 후 출력하시오.
예제 2. 키보드로 5명의 친구이름 입력 받아 배열에 저장하고 역순으로 출력하시오.
예제 3, 예제 2의 첫번째 친구이름과 마지막 친구 이름을 서로 바꾸시오.
예제 4. 로또번호를 생성하여 출력하시오. 
	(1~45)_중복안되게 45개 저장될 기억공간 만들고
	무한대 자리바꿈 (임의의 위치_ex 백만번)
예제 5. 금액을 1000원 단위로 입력하여 예제 4번의 로또번호를 금액만큼 출력하시오.
	매번 섞음 (앞에서 6개 끊어서) - 매번 새로운 번호 생성
	입력한 금액 / 1000원 횟수 반복 - 셔플링 호출 

예제 6. 다음 수를 배열에 저장하고 크기순으로 정렬하시오.
	자료 : 35,80,25,69,44,51,19,97

----------
정렬 알고리즘
데이터를 크기 순으로 나열하는 방법
selection sort
bubble sort
구현하기 쉬워서 가장 많이 씀

---------------------

같은 타입의 임시 기억장소 temp

String temp = name [0];
name [0] = name[4];
name[4] = temp; 

(책 177쪽에 메모)

---------------
for(String str:name) {
			System.out.printlf("%5s", str);
		}
	} 
반복자

사용 가능한 두가지 경우
-대상이 배열인 경우 
-collection framework 인경우
name 과 같은 타입의 변수 : 배열, 콜렉션프레임워크
배열의 맨 처번째 자료를 str 에 넣어줌
배열의 있는 값이 다 출력될때까지 ex 02에서부터 0번째부터 4번재까지

--------------------------------------------

Bubble Sort
=> 인접된 두자료의 크기를 비교하여 자리를 교환
자료가 n개 일 때 n-1 회전 수행

자료 : 35,80,25,69,44,51,19,97

한줄 비교 -> 1회전

어센딩 오름차순/ 디센딩 내림차순
기본은 어샌딩 (오름차순)
요구 조건 없으면 오름차순 !

각회전마다 오른 쪽 끝을 비ㄱ
각 회전 끝날때마다 오른 쪽 제외시킴
- 가장 큰 값 찾아서 가장 오른쪽에 둠 따라서 회전마다 오른 쪽 제외

바깥쪽 for 문은 (0~length-1)
안쪽은 length-1-i 값 


























